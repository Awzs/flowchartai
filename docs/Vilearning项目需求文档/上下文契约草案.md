# 上下文契约草案（Canvas Snapshot & AI Context）

## 1. 目的
规范前后端关于 Canvas 状态、AI 请求上下文、最新生成稿的传输结构，为阶段 0 的“生成→保存”闭环及后续上下文工程提供统一契约。

## 2. 数据结构约定

### 2.1 Canvas Snapshot
由前端在发送 AI 请求前生成，结构样例：
```json
{
  "elements": [...],            // Excalidraw 元素数组（裁剪为必要字段）
  "hasAiFlowchart": true,       // 是否存在 AI 生成的流程图元素
  "summary": "流程图摘要",        // generateAICanvasDescription 生成的文本
  "selection": {
    "elementIds": [...],        // 当前选中元素 ID
    "text": "选中内容摘要"
  }
}
```
> 生成逻辑参考 `src/components/canvas/ai-chat-sidebar.tsx:getCanvasState`。

### 2.2 AI Context Payload
随请求一并传给后端：
```json
{
  "canvasSnapshot": { ... },     // Canvas Snapshot（可为空）
  "lastMermaid": {
    "code": "...",
    "generatedAt": 1730512345678
  },
  "lastMindmap": {
    "raw": "{...}",
    "generatedAt": 1730512345678,
    "description": "最新导图摘要",
    "mode": "extend",
    "metadata": {
      "nodeCount": 48,
      "branchCount": 12,
      "fallbackUsed": false
    }
  },
  "requestedMode": "extend",     // 推断出的合适模式
  "mode": "text_to_mindmap"      // 当前 aiMode
}
```

### 2.3 API 响应结构
流式响应包含文本与工具调用事件；mindmap 生成部分：
```json
{
  "type": "tool-call",
  "toolName": "generate_mindmap",
  "args": {
    "mindmap_data": "{...JSON...}",
    "mode": "replace",
    "description": "导图摘要"
  }
}
```
前端将其交由 `displayRegistry` 解析并更新消息体。

## 3. 保存链路要求
1. 成功解析后将结构化数据存入：
   - `canvasContextRef.lastMindmap`（前端缓存，已实现）。
   - （待办）落地后端存储：建议写入 `displays` 表的 `structured_payload` 字段。
2. Extend 模式需带上 `lastMindmap` 的原始数据，后端可据此执行合并策略（当前尚未实现，需阶段 0 中补齐）。

## 4. 版本管理
- 在 `docs/Vilearning项目需求文档/上下文契约草案.md` 中维护最新契约版本，调整时同步更新版本号及变更记录。
- 建议后续引入 JSON Schema（例如 `src/lib/displays/schemas/*`）确保前后端校验一致。

## 5. 后续工作
- 完成 mindmap 保存 API，实现 extend 合并策略，并为上下文契约编写单元测试。
- 将当前草案提报评审，通过后作为阶段 0 的准入条件之一。
